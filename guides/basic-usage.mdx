---
title: 'Basic Usage'
description: 'Learn the fundamentals of using the Swarms API with practical examples'
---

# Basic Usage

This guide covers the fundamental concepts and common use cases for the Swarms API. You'll learn how to create agents, execute tasks, and build simple workflows.

## Prerequisites

Before you begin, make sure you have:

- [Set up your API key](/getting-started/api-key-setup)
- Installed the required libraries for your programming language
- Basic understanding of HTTP requests and JSON

## Your First API Call

Let's start with a simple health check to verify your connection:

```python
import requests
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()
API_KEY = os.getenv("SWARMS_API_KEY")
BASE_URL = "https://api.swarms.world"

# Set up headers
headers = {
    "x-api-key": API_KEY,
    "Content-Type": "application/json"
}

# Make a health check request
response = requests.get(f"{BASE_URL}/health", headers=headers)

if response.status_code == 200:
    print("✅ API connection successful!")
    print(f"Status: {response.json()['status']}")
else:
    print(f"❌ Connection failed: {response.status_code}")
```

## Creating Your First Agent

### Simple Text Generation

Start with a basic agent that generates text:

```python
def create_simple_agent():
    payload = {
        "agent_config": {
            "agent_name": "Content Writer",
            "description": "A helpful content writer",
            "system_prompt": "You are a professional content writer. Write clear, engaging content that matches the user's request.",
            "model_name": "gpt-4o-mini",
            "role": "worker",
            "max_loops": 1,
            "max_tokens": 1000,
            "temperature": 0.7,
            "auto_generate_prompt": False
        },
        "task": "Write a short paragraph about the benefits of renewable energy."
    }
    
    response = requests.post(
        f"{BASE_URL}/v1/agent/completions",
        headers=headers,
        json=payload
    )
    
    if response.status_code == 200:
        result = response.json()
        print("Generated content:")
        print(result['data']['response'])
    else:
        print(f"Error: {response.status_code}")
        print(response.text)

# Run the agent
create_simple_agent()
```

### Agent with Conversation History

Create an agent that maintains context across multiple interactions:

```python
def create_conversational_agent():
    # First message
    payload = {
        "agent_config": {
            "agent_name": "Travel Assistant",
            "description": "A helpful travel planning assistant",
            "system_prompt": "You are a travel planning expert. Help users plan their trips with personalized recommendations.",
            "model_name": "claude-3-5-sonnet-20240620",
            "role": "worker",
            "max_loops": 1,
            "max_tokens": 2000,
            "temperature": 0.8,
            "auto_generate_prompt": False
        },
        "task": "I'm planning a trip to Japan in March. What should I know?"
    }
    
    response = requests.post(
        f"{BASE_URL}/v1/agent/completions",
        headers=headers,
        json=payload
    )
    
    if response.status_code == 200:
        result = response.json()
        first_response = result['data']['response']
        print("First response:", first_response)
        
        # Follow-up with context
        follow_up_payload = {
            "agent_config": payload["agent_config"],
            "task": "What about cherry blossom season?",
            "history": [
                {
                    "role": "user",
                    "content": "I'm planning a trip to Japan in March. What should I know?"
                },
                {
                    "role": "assistant",
                    "content": first_response
                }
            ]
        }
        
        follow_up_response = requests.post(
            f"{BASE_URL}/v1/agent/completions",
            headers=headers,
            json=follow_up_payload
        )
        
        if follow_up_response.status_code == 200:
            follow_up_result = follow_up_response.json()
            print("\nFollow-up response:", follow_up_result['data']['response'])
    
    else:
        print(f"Error: {response.status_code}")

# Run the conversational agent
create_conversational_agent()
```

## Working with Reasoning Agents

### Mathematical Problem Solving

Use a reasoning agent for complex mathematical problems:

```python
def solve_math_problem():
    payload = {
        "agent_name": "Math Solver",
        "description": "Expert mathematical problem solver",
        "model_name": "claude-3-5-sonnet-20240620",
        "system_prompt": "You are an expert mathematician. Solve problems step by step, showing your reasoning clearly.",
        "max_loops": 1,
        "swarm_type": "reasoning-duo",
        "task": "Prove that the sum of any three consecutive integers is divisible by 3."
    }
    
    response = requests.post(
        f"{BASE_URL}/v1/reasoning-agent/completions",
        headers=headers,
        json=payload
    )
    
    if response.status_code == 200:
        result = response.json()
        print("Mathematical proof:")
        print(result['data']['response'])
    else:
        print(f"Error: {response.status_code}")

# Solve the math problem
solve_math_problem()
```

### Research and Analysis

Use a reasoning agent for research tasks:

```python
def conduct_research():
    payload = {
        "agent_name": "Research Analyst",
        "description": "Expert research analyst with systematic approach",
        "model_name": "claude-3-5-sonnet-20240620",
        "system_prompt": "You are a research analyst. Conduct thorough research, analyze information from multiple perspectives, and provide well-structured findings.",
        "max_loops": 2,
        "swarm_type": "ire",
        "task": "Research the impact of artificial intelligence on job markets in the next decade. Provide analysis from economic, social, and technological perspectives."
    }
    
    response = requests.post(
        f"{BASE_URL}/v1/reasoning-agent/completions",
        headers=headers,
        json=payload
    )
    
    if response.status_code == 200:
        result = response.json()
        print("Research findings:")
        print(result['data']['response'])
    else:
        print(f"Error: {response.status_code}")

# Conduct research
conduct_research()
```

## Building Multi-Agent Workflows

### Sequential Content Pipeline

Create a content creation workflow where agents work in sequence:

```python
def create_content_pipeline():
    payload = {
        "name": "Blog Post Creator",
        "description": "Creates blog posts from research to final draft",
        "agents": [
            {
                "agent_name": "Researcher",
                "description": "Gathers comprehensive information on topics",
                "system_prompt": "You are a research specialist. Gather comprehensive, accurate information from multiple sources.",
                "model_name": "gpt-4o",
                "role": "researcher",
                "max_loops": 1,
                "max_tokens": 4000,
                "temperature": 0.5,
                "auto_generate_prompt": False
            },
            {
                "agent_name": "Writer",
                "description": "Creates engaging content based on research",
                "system_prompt": "You are a content writer. Create engaging, informative content based on the research provided.",
                "model_name": "claude-3-5-sonnet-20240620",
                "role": "writer",
                "max_loops": 1,
                "max_tokens": 4000,
                "temperature": 0.8,
                "auto_generate_prompt": False
            },
            {
                "agent_name": "Editor",
                "description": "Reviews and improves content quality",
                "system_prompt": "You are an expert editor. Review content for clarity, accuracy, and engagement. Suggest improvements.",
                "model_name": "gpt-4o",
                "role": "editor",
                "max_loops": 1,
                "max_tokens": 4000,
                "temperature": 0.6,
                "auto_generate_prompt": False
            }
        ],
        "max_loops": 2,
        "swarm_type": "SequentialWorkflow",
        "task": "Create a comprehensive blog post about sustainable living practices for urban dwellers."
    }
    
    response = requests.post(
        f"{BASE_URL}/v1/swarm/completions",
        headers=headers,
        json=payload
    )
    
    if response.status_code == 200:
        result = response.json()
        print("Content pipeline result:")
        print(result['data']['result'])
        
        print("\nAgent outputs:")
        for agent in result['data']['agents']:
            print(f"\n{agent['agent_name']}:")
            print(agent['output'])
    else:
        print(f"Error: {response.status_code}")

# Run the content pipeline
create_content_pipeline()
```

### Parallel Analysis

Use concurrent workflows for independent analysis tasks:

```python
def parallel_analysis():
    payload = {
        "name": "Market Analysis",
        "description": "Analyzes market data from multiple perspectives",
        "agents": [
            {
                "agent_name": "Technical Analyst",
                "description": "Analyzes technical indicators and patterns",
                "system_prompt": "You are a technical analyst. Analyze market data for technical patterns and indicators.",
                "model_name": "gpt-4o",
                "role": "technical_analyst",
                "max_loops": 1,
                "max_tokens": 3000,
                "temperature": 0.5,
                "auto_generate_prompt": False
            },
            {
                "agent_name": "Fundamental Analyst",
                "description": "Analyzes fundamental business factors",
                "system_prompt": "You are a fundamental analyst. Evaluate business fundamentals, financial health, and market position.",
                "model_name": "claude-3-5-sonnet-20240620",
                "role": "fundamental_analyst",
                "max_loops": 1,
                "max_tokens": 3000,
                "temperature": 0.5,
                "auto_generate_prompt": False
            },
            {
                "agent_name": "Sentiment Analyst",
                "description": "Analyzes market sentiment and news",
                "system_prompt": "You are a sentiment analyst. Evaluate market sentiment based on news, social media, and public opinion.",
                "model_name": "gpt-4o",
                "role": "sentiment_analyst",
                "max_loops": 1,
                "max_tokens": 3000,
                "temperature": 0.5,
                "auto_generate_prompt": False
            }
        ],
        "max_loops": 1,
        "swarm_type": "ConcurrentWorkflow",
        "task": "Analyze the current state of the electric vehicle market from technical, fundamental, and sentiment perspectives."
    }
    
    response = requests.post(
        f"{BASE_URL}/v1/swarm/completions",
        headers=headers,
        json=payload
    )
    
    if response.status_code == 200:
        result = response.json()
        print("Market analysis results:")
        print(result['data']['result'])
        
        print("\nIndividual analyses:")
        for agent in result['data']['agents']:
            print(f"\n{agent['agent_name']}:")
            print(agent['output'])
    else:
        print(f"Error: {response.status_code}")

# Run parallel analysis
parallel_analysis()
```

## Error Handling

### Basic Error Handling

Implement proper error handling for your API calls:

```python
import time
from tenacity import retry, wait_exponential, stop_after_attempt

@retry(
    wait=wait_exponential(multiplier=1, min=4, max=10),
    stop=stop_after_attempt(3)
)
def make_api_request(url, headers, data=None):
    try:
        if data:
            response = requests.post(url, headers=headers, json=data, timeout=30)
        else:
            response = requests.get(url, headers=headers, timeout=30)
        
        # Handle rate limiting
        if response.status_code == 429:
            retry_after = int(response.headers.get('Retry-After', 60))
            print(f"Rate limited. Waiting {retry_after} seconds...")
            time.sleep(retry_after)
            raise Exception("Rate limited - retry")
        
        # Handle other errors
        response.raise_for_status()
        return response.json()
        
    except requests.exceptions.Timeout:
        print("Request timed out")
        raise
    except requests.exceptions.RequestException as e:
        print(f"Request failed: {e}")
        raise
    except Exception as e:
        print(f"Unexpected error: {e}")
        raise

# Use the error-handled function
def safe_api_call():
    try:
        result = make_api_request(
            f"{BASE_URL}/v1/agent/completions",
            headers=headers,
            data={"task": "Hello"}
        )
        return result
    except Exception as e:
        print(f"API call failed: {e}")
        return None
```

## Best Practices

### 1. Start Simple

- Begin with single agents for basic tasks
- Test thoroughly before moving to complex workflows
- Use the health endpoint to verify connectivity

### 2. Optimize Your Prompts

- Be specific about what you want the agent to do
- Provide clear context and examples
- Use appropriate temperature settings for your use case

### 3. Handle Errors Gracefully

- Implement retry logic with exponential backoff
- Log errors for debugging
- Provide fallback behavior when possible

### 4. Monitor Performance

- Track response times and token usage
- Monitor for rate limit issues
- Optimize based on usage patterns

## Next Steps

- [Advanced Features](/guides/advanced-features) - Learn about tools integration and complex workflows
- [Examples](/guides/examples) - See more real-world use cases
- [API Reference](/api-reference/endpoints) - Complete endpoint documentation
- [Error Handling](/api-reference/errors) - Understand error responses and handling
